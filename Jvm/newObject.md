###对象的创建
Java 程序中要创建一个类的实例时，我们总会new 个对象，但不曾了解在jvm中这个对象是如何创建的，这个对象的所有信息分别在在哪里存放，对象基本信息、属性、方法，等信息在哪里存放，以及如何使用。
在此总结下jvm中对象创建的过程，以及对象信息在内存中的存放位置。

当虚拟机遇到一条new指令时：

1、先检查所new的类是否已经被加载，在哪里检查？当然是方法区

	方法区存放了加载过的类信息。

	如果没有加载，那么先执行类的加载。

[类如何加载](classLoader.md)

2、通过类加载检查后，虚拟机为新生对象分配内存。（对象所需的内存大小在类加载完成后已经可以确定）

	这时只要在堆内存中分配空间即可。

3、对于内存的分配，也有两种情况：

（1）、可用内存，已使用内存规整
	
	只需在这两块内存间放一个指针即可，在分配时指针移动相应的要分配内存的大小。
	
（2）、可用内存，已使用内存夹杂在一起
	
	这是就需要一个列表去记录堆内存的使用情况。操作系统对内存的管理就是这样
	
4、还会有一个问题要考虑，即在多线程下，只有一个指针怎么保存一个线程分配了内存指针，没有修改时，另一个线程又分配内存。不会覆盖前一个新城分配的内存？

	这里引入了TLAB（本地线程分配缓冲）。每个线程只在自己的内存中分配

5、最后、对象被成功分配内存。我们晓得可以通过getClass（）方法获取类，默认比较两个对象实际比较的是对象内存的哈希值。

在分配完内存后，虚拟机会对对象进行必要的设置，对象的类，对象的哈希等信息都存放在对象头中，所以分配的内存绝不是属性的总合。

###对象的内存布局
####对象头
包括两部分：

	第一部分存储自身运行时的数据，例如GC标志位，MonirGC次数，哈希码，锁状态那个线程可以拥有等。（标记字MarkWord）

	第二部分存放指向方法区类数据的指针。在32位系统中，class指针大小为4字节，标记字为4字节。在64位系统中标记字为8字节。

####实例数据
	存放类的属性信息，包括父类的属性信息。数组的实例部分还包括数组的长度。实例信息按类分别4字节对齐

####对齐填充
	这是虚拟机要求对象起始地址必须是8字节的整数倍，可以说对齐填充没有什么特别的含义

###对象的访问定位
	引用是引用，对象实例是对象实例。引用存放在虚拟机栈中，数据类型为reference，对象实例存放在堆中。
	
	那么引用是如何指向对象实例的？

这种访问方式有两种：

>句柄池

>直接指向

使用句柄池，Java堆中将会划分出一部分内存作为句柄池，句柄包含对象类型指针指向方法区的类型信息，还有对象实例指针，指向堆中的实例地址。

reference引用直接指向堆中的对象实例，对象实例的对象头存放对象类型指针。

第一种可以在对象实例在GC时移动的时候只改变句柄池中二对象实例指针，而不是改变reference引用本身。第二种方法就死访问速度快，减少了一次指针定位的时间开销。

Hotspot采用了第二种方式。

###总结

	Java的内存区域是Java深入学习的必要条件。学习对象的创建过程，对象的存储，方法和属性的存放位置，更有助于我们写Java程序。